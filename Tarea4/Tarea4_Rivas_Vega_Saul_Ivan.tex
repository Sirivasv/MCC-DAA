\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage[spanish]{babel}
 \usepackage{url}
\usepackage[spanish, fixlanguage]{babelbib}
\bibliographystyle{IEEEtran}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{positioning, fit}
\usetikzlibrary{babel}

\title{Tarea 4}

\author{
	Saul Ivan Rivas Vega \\
	\\
	Diseño y análisis de algoritmos\\
\\
	Equipo Completo:\\
		Yadira Fleitas Toranzo\\
		Diego de Jesús Isla Lopez\\
		Saul Ivan Rivas Vega\\
}

\date{\today}

\begin{document}
	\maketitle
	\pagebreak
	\section{Ejercicio 1.}
	\subsection{Da un ejemplo de una familia de digráficas de $n$ vértices con pesos no negativos tal que admita una ejecución del algoritmo de Dijkstra en la cual todos los nodos actualizan a su padre y su estimación de distancia $d(v)$ una sola vez; es decir, la primera oferta de camino que reciben, es la del camino mas corto. Demuestra que tu ejemplo cumple lo que se pide.}
	\paragraph{}Sea $F$ la familia de digráficas que cumpla las siguientes condiciones para cada miembro $G$ de ella:\\
	\begin{itemize}
		\item La gráfica $G$ tiene un conjunto de aristas ponderadas $E$ tal que $|E| = n$ donde cada arista tiene un peso mayor o igual a cero y un conjunto de vértices $V$ tal que $|V| = n$.
		\item $G$ es conexa.
		\item Todo $v\in V$ tiene $inDegree(v) = 1$, es decir que tienen exactamente una sola arista de entrada.
		\item Todo $v\in V$ tiene $outDegree(v) = 1$, es decir que tienen exactamente una sola arista de salida. 
		\item Solo hay un ciclo y todo $v\in V$ esta en el ciclo.
	\end{itemize}
	Un miembro de esta familia con $n=6$ es:\\
	\begin{center}
	\begin{tikzpicture}[roundnode/.style={draw,shape=circle,fill=black!40,minimum size=1mm}]
		\tikz
		%Nodes
		\node[roundnode,label={north west:$v_1$}]      (v1)                     {};
		\node[roundnode,label={north east:$v_2$}]      (v2)       [right=of v1] {};
		\node[roundnode,label={east:$v_3$}]      (v3)       [below right=of v2] {};
		\node[roundnode,label={south east:$v_4$}]      (v4)       [below left =of v3] {};
		\node[roundnode,label={south west:$v_5$}]      (v5)       [left =of v4] {};
		\node[roundnode, label={west:$v_6$}]      (v6)       [below left =of v1] {};
		%Lines
		\draw[->] (v1) -- (v2) node[midway,below] {2};
		\draw[->] (v2) -- (v3) node[midway,below] {4};
		\draw[->] (v3) -- (v4) node[midway,below] {1};
		\draw[->] (v4) -- (v5) node[midway,below] {4};
		\draw[->] (v5) -- (v6) node[midway,below] {0};
		\draw[->] (v6) -- (v1) node[midway,below] {5}; 
	\end{tikzpicture}
	\end{center}
	\paragraph{Demostración} Por contradicción.\\
	Supongamos que durante una ejecución el algoritmo de Dijkstra al empezar en cualquier nodo $s\in G$, existe un nodo $v_i$ tal que $v_i \neq s$ y además actualizó su estimación de distancia $d(v_i)$ mas de una vez.\\
	Entonces el algoritmo hizo una primera estimación de distancia $d(v_i)_1$ siguiendo un camino de nodos $p$ desde $s$ hasta $v_i$. Ahora para realizar una estimación adicional $d(v_i)_2$ tal que $d(v_i)_2 < d(v_i)_1$ debió encontrar un segundo camino $p'$ para llegar a $v_i$.\\
	Sin embargo, siendo $G$  miembro de la familia $F$ se cumple que todo $v\in G$ tiene una sola arista de salida y una de entrada, y solo hay un ciclo donde todo $v\in G$ esta en el. Le sigue que, para llegar a $v_i$ desde $s$, se puede:
	\begin{enumerate}
		\item Seguir el ciclo hasta llegar a $v_i$.
		\item Completar el ciclo $z$ veces ($z>=1$) y volver a llegar a $v_i$.
	\end{enumerate}  
	El camino resultante de al usar el segundo método será siempre mayor o igual al primero puesto que los pesos son mayores o iguales a 0 manteniendo o incrementando el camino del primer método.\\
	Por lo tanto existe un solo camino mínimo entre cualquier par de nodos en $G$. Entonces no existe un segundo camino $p'$ tal que al llegar a $v_i$ su estimación de distancia cumpla que $d(v_i)_2 < d(v_i)_1$ y en la ejecución no hubo una actualización adicional a la primera, pero esto es una contradicción a nuestra suposición inicial. Finalmente, en cualquier ejecución del algoritmo empezando en cualquier nodo $s\in G$, todos los nodos actualizan a su padre y su estimación de distancia $d(v_i)$ una sola vez.
	\pagebreak
	\subsection{Da un ejemplo de una familia de digráficas con pesos no negativos tal que cualquier ejecución del algoritmo de Dijkstra requiera que algún vértice actualice su padre y su estimación de distancia dos veces. Demuestra que tu ejemplo cumple lo que se pide.}
		\paragraph{}Sea $F$ la familia de digráficas que cumpla las siguientes condiciones para cada miembro $G$ de ella:\\
	\begin{enumerate}
		\item Tiene un nodo inicial $s$ el cual no tiene aristas de entrada.
		\item $s$ tiene una arista de salida con peso igual a 1.
		\item Tiene un nodo final $v_f$ el cual no tiene aristas de salida.
    	\item $v_f$ tiene una arista de entrada con peso igual a 1.
		\item Para todo $v\in G$ tal que $v\neq s$ y $v\neq v_f$, se cumple:
			\begin{enumerate}
				\item $v$ tiene una sola arista de entrada con peso igual a 1.
				\item $v$ tiene una sola arista de salida con peso igual a 1.
			\end{enumerate}
	\item Desde $s$ se puede llegar a todos los otros vértices.
	\item Hay una arista adicional desde $s$ a $v_f$ con peso $2n$.
	\item $s$ tiene exactamente 2 aristas de salida.
	\item $v_f$ tiene exactamente 2 aristas de entrada.
	\end{enumerate}
	Un miembro de esta familia con $n=4$, donde $s = v_1$ y $v_f = v_4$ es:\\
	\begin{center}
		\begin{tikzpicture}[roundnode/.style={draw,shape=circle,fill=black!40,minimum size=1mm}]
		\tikz
		%Nodes
		\node[roundnode,label={north west:$v_1$}]      (v1)                     {};
		\node[roundnode,label={north west:$v_2$}]      (v2)       [right=of v1] {};
		\node[roundnode,label={north west:$v_3$}]      (v3)       [right=of v2] {};
		\node[roundnode,label={north west:$v_4$}]      (v4)       [right =of v3] {};
		%Lines
		\draw[->] (v1) -- (v2) node[midway,below] {1};
		\draw[->] (v2) -- (v3) node[midway,below] {1};
		\draw[->] (v3) -- (v4) node[midway,below] {1};
		\draw[->] (v1) to [out=270,in=240] node[pos=0.5, below] {8}  (v4) ;
		\end{tikzpicture}
	\end{center}
	\paragraph{Demostración} Propongamos al vértice $v_f$ como aquel nodo que actualice su padre y su estimación de distancia dos veces al comenzar desde el nodo $s$.\\
	La primer estimación de distancia $d(v_f)_1$se realiza al ejecutar el algoritmo iniciando en $s$, pues $v_f$ es vecino directo por la propiedad $7$. $d(v_f)_1$ vale $2n$. Ahora para una segunda estimación se puede seguir el camino de la otra arista de peso 1 de  $s$, dicho camino llegará a $v_f$ por  la propiedad $6$. \\ Este camino tendrá como peso total la suma de los pesos de las aristas, cada arista en ese camino tiene peso 1, y como pasa por todos los nodos y todos menos $v_f$ tienen una arista de salida de peso 1, significa que hay $n-1$ aristas. Posteriormente tenemos que esta segunda estimación $d(v_f)_2$ vale $n-1$. Finalmente como $d(v_f)_2  < d(v_f)_1$ habrá forzosamente una segunda actualización.
	\section{Ejercicio 2.}
	\subsection{De acuerdo con el algoritmo de Dijkstra que revisamos en clase, para cada $n\in \mathbb{N}$ con $n>2$, presenta una familia de gráficas de $n$ vértices con pesos tanto positivos como negativos y sin ciclos dirigidos de longitud negativa para la cual se cumple que si $G$ es una gráfica de la familia, el algoritmo de Dijkstra falla en encontrar el camino más corto entre $s$ y algún otro vértice de $G$. Demuestra que de hecho existe tal vértice.}
	\paragraph{}Sea $F$ la familia de digráficas que sigue el siguiente proceso de construcción:\\
	Para $G_0$ se tiene la siguiente gráfica:
		\begin{center}
			\begin{tikzpicture}[roundnode/.style={draw,shape=circle,fill=black!40,minimum size=1mm}]
			\tikz
			%Nodes
			\node[roundnode,label={north west:$v_1$}]      (v1)                     {};
			\node[roundnode,label={north west:$v_2$}]      (v2)       [above right=of v1] {};
			\node[roundnode,label={north east:$v_3$}]      (v3)       [below right=of v2] {};
			%Lines
			\draw[->] (v1) -- (v2) node[midway,above] {$z$};
			\draw[->] (v2) -- (v3) node[midway,above] {$-z$};
			\draw[->] (v1) -- (v3) node[midway,below] {1};
			\end{tikzpicture}
		\end{center}
		Donde $z = 2n$, en $G_0$ $z=6$.\\
		Ahora para cualquier otro $G_i$ con $i>0$ se agregara una arista del último nodo de $G_{i-1}$, el cual es $v_{i+2}$, a un nuevo nodo $v_{i + 3}$ con peso 1: 
				\begin{center}
			\begin{tikzpicture}[roundnode/.style={draw,shape=circle,fill=black!40,minimum size=1mm}]
			\tikz
			%Nodes
			\node[roundnode,label={north west:$v_1$}]      (v1)                     {};
			\node[roundnode,label={north west:$v_2$}]      (v2)       [above right=of v1] {};
			\node[roundnode,label={north east:$v_3$}]      (v3)       [below right=of v2] {};
			\node[label={$...$}]      (v4)       [right=of v3] {};
			\node[roundnode,label={north east:$v_{i+2}$}]      (v5)       [right=of v4] {};
    		\node[roundnode,label={north east:$v_{i+3}$}]      (v6)       [right=of v5] {};
			%Lines
			\draw[->] (v1) -- (v2) node[midway,above] {$z$};
			\draw[->] (v2) -- (v3) node[midway,above] {$-z$};
			\draw[->] (v1) -- (v3) node[midway,below] {1};
			\draw[->] (v3) -- (v4) node[midway,below] {1};
			\draw[->] (v4) -- (v5) node[midway,below] {1};
    		\draw[->] (v5) -- (v6) node[midway,below] {1};
			\end{tikzpicture}
		\end{center}
	\paragraph{Demostración} La ejecución de Dijkstra empieza en $v_1$ y propongamos que donde falla en encontrar el camino mínimo es para el nodo $v_3$.\\
	En la primera ocasión donde se estiman distancias a partir de $v_1$ se marca como explorados a $v_2$ y a $v_3$.
	La estimaciones son: $d(v_2)=z$ y $d(v_3)=1$. Esas son las primeras estimaciones para cualquier ejecución del algoritmo con nodo inicial en $v_1$.\\
	Ahora como $z=2n$ y $2n>1$ el algoritmo seguirá explorando ahora con $v_3$. Solo se consideraría ir por $v_2$ cuando la estimación de distancia para algún nodo $v_i$ cumpla que $d(v_i) > 2n$, sin embargo como las aristas tienen peso 1, y no hay mas de $n-3$ aristas a partir de $v_3$, nunca se considerará explorar a partir de $v_2$.\\
	Por lo tanto al explorar todos los nodos se terminará la ejecución del algoritmo y la estimación de distancia para $v_3$ es $d(v_3)=1$, sin embargo al tomar el camino de $v_1$ a $v_2$ y luego a $v_3$ se tendría una distancia de $0$, la cual es menor a $1$. Finalmente para cualquier gráfica $G$ miembro de la familia al ejecutar el algoritmo de Dijkstra empezando en $v_1$, el algoritmo fallará en encontrar la distancia mínima para el nodo $v_3$.
	\subsection{Toma una gráfica de la familia que propones y muestra que Bellman-Ford si encuentra el camino que Dijkstra no.}
	Tomemos a $G_0$:
	\begin{center}
		\begin{tikzpicture}[roundnode/.style={draw,shape=circle,fill=black!40,minimum size=1mm}]
		\tikz
		%Nodes
		\node[roundnode,label={north west:$v_1$}]      (v1)                     {};
		\node[roundnode,label={north west:$v_2$}]      (v2)       [above right=of v1] {};
		\node[roundnode,label={north east:$v_3$}]      (v3)       [below right=of v2] {};
		%Lines
		\draw[->] (v1) -- (v2) node[midway,above] {$6$};
		\draw[->] (v2) -- (v3) node[midway,above] {$-6$};
		\draw[->] (v1) -- (v3) node[midway,below] {1};
		\end{tikzpicture}
	\end{center}
\end{document}